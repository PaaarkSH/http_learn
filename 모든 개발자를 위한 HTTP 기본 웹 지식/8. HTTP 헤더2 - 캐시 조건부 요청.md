# HTTP 헤더2 - 캐시 조건부 요청

# 캐시 기본 동작

## 캐시가 없을 때

### 첫 번째 요청

- 만약 우리가 서버에서 start.jpg 파일을 요청한다고 가정
- 1.1M 파일 전송
    - 바이트 코드들 http 통신으로 전송
- HTTP 헤더: 0.1M
- HTTP 바디: 1.0M
- 총 1.1MB 네트워크를 차지하면서 웹브라우저를 타고 들어와서 요청
- 만약 캐시가 없다면 또 똑같이 1.1MB 의 용량을 차지하는 요청을 보냄

### 결론

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험

## 캐시 적용

### 첫 번째 요청

- star.jpg 를 데이터 요청
- 서버에서 http 헤더에 cache-control 추가
    - **cache-control: max-age=60**
    - 캐시가 유효한 시간
    - 60초 동안은 캐시가 유효하다는 뜻
- 웹 브라우저에는 캐시를 저장하는 저장소가 있음
    - 응답 결과를 캐시에 저장

### 두번째 요청

- 캐시 저장소를 뒤짐
- 캐시 데이터가 있으면 캐시 데이터 조회

### 결론

- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
- 비싼 네트워크 사용량을 줄일 수 있다
- 브라우저 로딩 속도가 매우 빠르다
- 빠른 사용자 경험

### 세 번째 요청 - 캐시 시간 초과

- 만약 60초가 지나갔다면?
- 60초가 지나갔다면 다시 데이터를 요청함
- 기존의 데이터를 지우고 데이터를 다시 씀
    - 이 과정에서 1.1MB 를 사용됨

### 결과

- 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다
    - 60초가 지난걸 영어로 스테일 하다 표현
        - 신헌하지 않음
    - 서버가 가지고 있는것과 캐시와 데이터가 달라질 수 있음
- 이때 다시 네트워크 다운로드가 발생한다
- 잘 생각해보면 이미지는 구지 바뀌지 않았을텐데 다시 받는건 좀 아까움
    - **만약 데이터가 똑같다면?**
        - 검증 헤더가 필요

# 검증 헤더와 조건부 요청1

## 캐시 시간 초과

- 캐시 유효시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타남
    - 서버에서 기존 데이터를 변경함
        - 이거는 진짜 데이터가 변경된것
    - 서버에서 기존 데이터를 변경하지 않음
        - 이거를 용량도 큰데 다시 받을 필요가 있을까?

## 검증헤더 조건부 요청

- 캐시 만료 후에도 서버에서 데이터를 변경하지 않음
- 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다
    - 왜냐면 데이터가 변경되지 않았기 때문에
- **단 클라이언트와 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요**

## 검증 헤더 추가

### 첫 번째 요청

- 만약 처음 요청을 했을때 Last Modified 라는걸 요청 할 수 있음
    - Last-Modified: 2020년 11월 10일 10:00:00
    - 데이터가 마지막에 수정된 시간
    - 쉽게 이해하기위해서 한글을 썻지만 UTC 시간으로 맞춰서 시간이 온다
- 이제 브라우저 캐시에 데이터만 저장하는게 아니라 최종 수정일도 넣음

### 두번째 요청

- 웹 브라우저가 서버에 요청을 보낼때 if-modifed-since 헤더를 붙여서 보냄
    - if-modifed-since: 2020년 11월 10일 10:00:00
- 서버에서는 최종 요청일을 서버에서 검증 할 수 있음
- 서버에서는 이 날짜를 보고 판단 할 수 있음
- **만약 수정이 안됬다면?**
    - 응답 HTTP 메세지로 304 메세지를 보냄
    - HTTP/1.1 304 Not Modified
        - **HTTP 바디가 없음**
            - 바디부가 실제 용량을 차지하는 부분이니까
        - 기존에는 1.1MB 를 보냈지만 헤더부분 0.1 MB 부분만 전송하는 것
    - cache-control 이나 Last-Modified 도 그대로 보냄

### 정리

- 캐시 유효 시간이 초과해도 서버의 데이터가 갱신하지 않으면
- 304 Not Modified + 헤더 메타 정보만 응답
    - 바디 없음
- **Last-Modified: 검증 할 수 있는 값**
- **if-modifed-since: 조건부 요청**
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드
    - 0.1MB 만 다운로드 하면 되는것
- 매우 실용적인 해결책
    - 대부분의 브라우저들이 해당 매커니즘을 사용하고있음
    - 구글의 png 파일을 다운로드 하는걸 개발자 도구로 보자
        - 그러면 색이 연한색으로 다운로드 하는걸 볼 수 있음
        - 그것이 캐시에서 불러온것
        - 해당 데이터를 더블클릭해서 보면 새창에서 해당 사진을 볼 수 있음
        - 그 다음 새로 고침을 하면 304 상태 코드를 리턴하는걸 확인하는게 가능함

# 검증 헤더와 조건부 요청2

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
    - Last-Modified, ETag

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- if-Modified-Since: Last-Modified 사용
- if-None-Match: ETag 사용
- 조건이 만족하면 200 OK
- 조건이 만족하지 않으면 304 Not Modified

## 예시

### if-Modified-Since: 이후에 데이터가 수정되었으면?

- 데이터 미변경 예시
    - 캐시: 2020년 11월 10일 10:00:00 vs 서버 2020년 11월 10일 10:00;00
        - 변경이 안일어났음
    - **304 Not Modified,** 헤더 데이터만 전송
        - 바디 미포함
        - 너의 캐시로 리다이렉션 하라
    - 전송 용량 0.1 MB(헤더 0.1 바디 1)
- 데이터 변경 예시
    - 캐시: 2020년 11월 10일 10:00:00 vs 서버 2020년 11월 10일 **11**:00:00
        - 진짜 수정이 되버렸음
    - **200 OK** 모든 데이터 전송
        - 바디 미포함
    - 전송 용량 1.1MB

## if-Modified-Since, Last-Modified 단점

- 1초 미만 단위로 캐시 조정이 불가능
    - 사실 이런 일이 있을가 싶긴함
    - 날짜가 끝이 초단위라 안됨
- 날짜 기반의 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
    - a → b → a 이렇게 수정하면 결국 a 가 되버리지만 날짜가 변경됨
    - 서버 입장에서는 파일의 날짜는 갱신되지만 파일은 갱신되지 않음
    - 이런 경우에도 전체 다운로드
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
    - 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우
- 서버에서 캐시 컨트롤을 할수있는 매커니즘이 있음
    - **ETag**

## ETag, Ig-None-Match

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - ex) Etag: “v1.0”, ETag: “a2jodwjekj3”
    - 날짜가 아니라 임의의 이름을 달아놓는 방법
    - 파일이나 이런건 해시 알고리즘을 달아서 해시 이름을 달아 놓을 수 있음
        - 파일의 콘텐츠가 같으면 항상 같은 해시값이 나옴
- 데이터가 변경되면 이 이름을 바꾸어서 변경함
    - Hash 를 다시 생성
    - ex) ETag: “aaaaaa” → ETag: “bbbbbb”
- 진짜 단순하게 ETag 만 보내서 같으면 유지, 다르면 다시 받기!

## 첫 번째 요청

- 서버에서 받을 때 ETag 를 내려줌
    - ETag: “aaaaaaaaaaa”
- 캐시를 저장할때 Etag 도 저장함
- 60초가 지났음
- 클라이언트가 서버에 요청을 보낼때 If-None-Match: “aaaaaaaaa” ETag 를 보냄
- 서버에서 볼때 같은 ETag 를 가지고있는걸 보면 실패 했다고 보고 304 를 보냄
    - **부정어라서 햇갈릴 수 있는데 데이터가 변하지 않았기 때문에 부정어라고 봐야함**
- 부정어를 다시 또 받으면 또 갱신

## ETag, Ig-None-Match 정리

- 진짜 단순하게 ETag 만 서버에서 보내서 같으면 유지, 다르면 다시 받기!
- **캐시 제어 로직을 서버에서 완전히 관리**
- 클라이언트는 단순히 이 값을 서버에 제공
    - 클라이언트는 캐시 매커니즘을 모름
- ex)
    - 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag 를 동일하게 유지
    - 어플리케이션 배포 주기에 맞춰 ETag 를 모두 갱싱

# 검증 헤더와 조건부 요청 헤더

## 캐시 제어 헤더

- Cache-Control: 캐시 제어
- Pragma: 캐시 제어
    - 하위 호환
- Expires: 캐시 유효 기간
    - 하위 호환

## Cache-Control: 캐시 제어

### 캐시 지시어(directives)

- Cache-Control: **max-age**
    - **캐시 유효 시간**, 초 단위
- Cache-Control: **no-cache**
    - 캐시를 안해도 된다?
    - 데이터는 캐시 해도 되지만, 항상 캐시를 쓰기 전에 **원(origin) 서버에 검증하고 사용**
        - 바뀌었는지 안바뀌었는지
        - 원 (origin) 서버
            - 우리는 보이지 않지만 cache proxy 서버라는게 있고 이걸 거쳐서 진짜 나의 서버에 접근 할 수 있음
            - 중간 서버에서 캐시할 수 있음
            - 중간 서버에서 캐시 할 수 없고 원 서버까지 가야된다는 의미
- Cache-Control: no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨
    - 메모리에서 사용하고 최대한 빨리 삭제
    - 주민등록번호나 카드 번호나 이런것들
- no-cache 랑 no-store 는 햇갈리면 안됨

## Pragma

### 캐시 제어 (하위 호환)

- Pragma: no-cache
- HTTP 1.0 하위 호환
- 지금은 거의 사용하지 않지만 하위 호환 떄문에 사용하는 경우가 있음

## Expires

### 캐시 만료일 지정(하위 호환)

- expires: Mon 01 Jan 1990 00:00:00 GMT
    - 캐시 만료일을 정할 수 있음
    - max-age 는 초단위로 사용
        - 초단위로 하면 그냥 다음 날짜를 생각해서 넣으면 되기 때문에 생각보다 더 유연함

- 캐시 만료일을 정확한 날짜로 지정
- HTTP 1.0 부터 사용
- **지금은 더 유연한 Cache-Control: max-age 권장**
- Cache-Control: max-age 와 함께 사용하면 Expires 는 무시

## 검증 헤더와 조건부 요청 헤더

- **검증 헤더(Validator)**
    - **ETag**: “v1,0” 또는 “asd98s9das”
    - **Last-Modified:** Thu, 04 Jun 2020 07:19:24 GMT
- **조건부 요청 헤더**
    - if-Match, if-None-Match: ETag 사용
    - if-Modified-Since, if-Unmodified-Since: Last-Modified 사용
    - 서로 반대개념

# 프록시 캐시

## 원 서버 직접 접근

### origin 서버

- 한국의 클라이언트(웹 브라우저) 가 미국에 있는 원 서버로 통신한다고 가정
    - 0.5초 걸린다고 가정
- 그러면 모든 사람이 0.5초가 걸림

### 프록시 캐시 도입

- 보통 CDN 서비스라고 해서 이걸 많이 사용함
    - AWS 는 클라우드 프론트라는걸 사용함
- 미국의 원 서버 입장에서는 이렇게 되면 너무 답답함
- 한국 어딘가에 프록시 캐시 서버를 넣어놓고 DNS 요청이 들어올때 미국 원 서버를 직접 들어가는게 아니라 캐시 서버를 거쳐서 오도록 설정
    - DNS 조작이 필요함
- **웹 브라우저가 프록시 캐시 서버를 접근하게 만듬**
    - 0.1 초 걸린다고 가정
- 기존의 0.5를 받던게 0.1 이 걸리는것
- 이래서 우리가 유튜브를 빨리 볼 수 있는것임
    - 우리가 사람들이잘 안보는 외국 컨텐츠를 보면 너무 느림
    - 사람들이 자주보는 컨텐츠를 보면 엄청 빠름
    - 이거는 사실 한국 어딘가에 있는 서버에서 여러번 다운로드 받는것
- 이런걸 CDN 서비스 라고함
    - 
- 캐시는 최초의 요청은 빠르지 않음
    - 두번째 요청부터 캐싱된 정보로 빨라짐
        - 중간에서 공용으로 사용하는 캐시

## Cache-Control

### 캐시 지시어 directive - 기타

- **Cach-Control: public**
    - 응답이 public 캐시에 저장 되어도 됨
- **Cach-Control: private**
    - 응답이 해당 사용자만을 위한것
    - **Public 에 저장되면 안됨**
        - 내 개인 정보가 캐시 값이 되면 안되자나
    - private 캐시에 저장해야함(기본값)
- **Cach-Control: s-maxage**
    - 프록시 캐시에만 적용되는 max-age
    - 이런게 있다 정도만 알면 댐
- **Age: 60(Http 헤더)**
    - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)
        - 프록시 캐시에서 걸린 시간이라고 이해하면 됨
    - 우리한테 중요하진 않음

# 캐시 무효화

## Cache-Control

### 확실한 캐시 무효화 응답

- **Cache-Control: no-cache, no-store, must-revalidate**
- **Pragma: no-cache**
    - HTTP 1.0 하위 호환
        - 과거 브라우저에서 요청이 올지 모르기 때문
- 캐시를 적용하면 캐시가 안되는게 안되는게 아닌가???
    - 아님 브라우저들이 GET 일 경우 임의로 캐시 해버림
- 이렇게 까지 넣어줘야 확실히 캐시가 안됨

## 캐시 지시어(directives) - 확실한 캐시 무효화

- **Cache-Control: no-cache**
    - 데이터는 캐시해도 되지만 항상 원 서버에 검증
    - 이름 주의
- **Cache-Control: no-store**
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨
        - 메모리에서 사용하고 최대한 빨리 삭제
- **Cache-Control: must-revalidate**
    - 캐시 만료 후 최초 조회시 **원 서버에 검증해야함**
    - 원서버 접근 실패시 반드시 오류가 발생해야함
        - 504 Gateway Timeout
    - must-revalidate 는 캐시 유효 시간이라면 캐시를 사용함
- **Pragma: no-cache**
    - HTTP 1.0 하위 호환
        - 얘네들은 저 위의 3개 지시어를 모르니까
- 네이버는 3개의 지시어만 가지고있음
    - 구글의 경우 더 구닥다리 웹 프로젝트까지 지원을 해줘야되기 때문에 다 지원해줘야됨
    - 요즘엔 하지 말라는것 까지 들어가있음

## no-cache VS must-revalidate

### no-cache 기본동작

- no-cache 는 ETag 같은걸 물고 들어감
- 그럼 프록시 캐시 서버를 감
- 프록시 서버는 no-cache 인걸 보고 여기서 처리는 못하고 원서버에 요청
- 원서버가 검증을 해봄
- 그리고 응답을 해줌
- 브라우저 캐시에 no-cache 를 저장함

- 근데 여기서 중요한게 있음
- **no-cache 로 보냈는데 프록시 캐시 서버가 원 서버와 네트워크가 단절이 되서 접근 불가가 될 경우**
    - 보통 프록시 캐시 서버에 옜날 데이터라도 보내주자는 세팅이 되어있음
    - 오류가 나는것 보다는 옛날 데이터가 보여주는게 나으니까
    - 그러면 200으로 응답을 할  수 도 있음
- 순단 네트워크 단질이 될 수 있을때 프록시 캐시가 응답할 수 있음

### must-revalidate  의 경우

- **프록시 캐시가 원서버와 단절이 됬을때 무조건 504 Gateway TimeOut 오류를 발생!**
- 예를 들어 통장 잔고라던가 이런 것들은 당연히 옛낧 데이터를 보여주면 안되니까
- **이것 때문에 must-revalidate 가 꼭 필요함**