# HTTP 헤더1 - 일반 헤더

# HTTP 헤더 개요

## 복습

- header-field = field-name “:” OWS field-value OWS
    - OWS: 띄어쓰기 없음
- field-name 은 대소문자 구분 없음

## 용도

- **HTTP 전송에 필요한 모든 부가 정보**
    - 예) 메세지 바디의 내용, 메세지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보…
    - 
- 표준 헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능

## 분류 - RFC2616 과거

- 헤더 분류
    - General 헤더: 메세지 전체에 적용되는 정보
        - 예) connection: close
        - 요청 메세지든 응답 메세지든 이런거에 구분 없이 그냥 메세지 전체에 적용되는 헤더
    - Request 헤더: 요청 정보
        - 예) User-Agent: Mozilla / 5.0 (Macintosh
            - 웹 브라우저 정보
        - 요청을 보낼때
    - Response 헤더: 응답정보
        - 예) Server: Apache
            - 서버 정보
        - 응답을 보낼때
    - Entity 헤더: 엔티티 바디 정보
        - 예) Content-TypeL text/html Content-Length: 3423
        - 콘텐트 타입의 바디에 들어가는 정보

### HTTP BODY

- 메세지 본문은 엔티티 본문을 전달하는데 사용
- 엔티티 문은 요청이나 응답에서 전달할 실제 데이터
    - 쉽게 얘기 해서 메세지 본문 안에 엔티티 본문을 담아서 전송
- **엔티티 헤더**는 **엔티티 본문**의 데이터를 해석할 수 있는 정보 제공
    - 데이터유형(html json) 데이터 킬이, 압축 정보 등

> 1999년 RFC2616 → 2014년 RFC7230 ~ 7235 등장
> 
- 엔티티 바디라는 용어가 사라짐

## RFC723x 변화

- 엔티티 → 표현(Representation)
- Representation = Representation Metadata + Representation Data
- 표현 = 표현 메타데이터 + 표현 데이터

## HTTP BODY

### message body - RFC7230(최신)

- 메시지 본문을 통해 표현 데이터 전달
    - html 이든 json 이든 xml 이든 데이터를 전달하는 것을 표현이라고 말함
    - 엔티티라는 용어가 필요 없어
- 메시지 본문 = **페이로드**
- **표현**은 요청이나 응답에서 잔달할 실제 데이터
    - 표현 = 표현 헤더 + 표현 데이터
- **표현 헤더**는 **표현 데이터**를 해석할 수 있는 정보를 제공
    - 데이터 유형 HTML JSON 데이터 길이, 압축 정보 등등
- 참고: 표현 헤더는 표현 메타 데이터와, 페이로드 메세지를 구분해야 하지만, 이걸 생략 가능

HTTP 1.1 200 OK

Content-Type: text/html;charset=UTF-8
Content-Length: 3423 
→ 표현헤더

<html> <body> … </body></html>
→ 표현 데이터

# 표현

- 표현 헤더는 전송, 응답 둘다 사용
- 표현은 리소스가 있음
    - 회원 리소스를 html 표현이든 json 표현으로 전달하든
    - 리소스는 매우 추상적인 개념
        - 사실 리소스가 뭔지도 모르고 데이터인것만 알기 때문
        - db 의 바이너리를 그냥 다 넘길순 없으니
    - 그래서 데이터를 XML JSON HTML 로 표현한다는 말을 쓰는것

## Content-Type : 표현 데이터의 형식

### 표현 데이터의 형식 설명

- 미디어 타입, 문자 인코딩
    - text/html; charset=utf-8
    - application/json
    - image/png

## Content-Encoding : 표현 데이터의 인코딩

- 표현 데이터를 압축하기 위해 사용
- 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
- 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
- 예
    - gzip
        - 압축
    - deflate
    - identity
        - 압축 안했

## Content-Language : 표현 데이터의 자연 언어

- 표현 데이터의 자연 언어를 표현
- 예)
    - ko
    - en
    - en-US
- 우리가 외국 사이트에 들어갈때 클라이언트가 읽을때 처리를 할 수 있음
- 

## Content-Length : 표현 데이터의 길이

- 사실은 명확하게 말하자면 페이로드 헤더에 맞음
    - 길이가 사실은 표현 자체랑은 무관하기 떄문
    - 그러면 너무 복잡해져서 그냥 표현 헤더로 봅시
- 바이트 단위
- Transfer-Encoding(전송 코딩)을 사용하면 Content-Length 를 사용하면 안됨
    - 전송코딩 안에 정보가 들어가있기 때문
    - 

# 콘텐츠 협상(Content Negotiation)

## 클라이언트가 선호하는 표현 요청

- Accept:
    - 클라이언트가 선호하는 미디어 타입 전달
        - 어떤 클라이언트는 JSON 을 선호하고 어떤 클라이언트는 XML 을 선호할 수 있음
        - 그러면 우선순위를 높이면 됨
- Accept-Charset:
    - 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding:
    - 클라이언트가 선호하는 압축 인코딩
- Accept-Language:
    - 클라이언트가 선호하는 자연언어
    
- 협상 헤더는 요청시에만 사용
- 처음 공부할때 정말 어려움
    - 무슨말을 하는지 이해하기 어려움
    - 백엔드 프레임워크에 협상을 지원하는 기술이 여러가지 있는데 처음 볼때 이해하기 어려움
- 내용은 간단함
    - 클라이언트가 원하는 표현에 맞춰서 데이터를 만들어준다는 의미

## Accept-Language 적용 전

- 제일 이해하기 쉬움

- 우리가 한국어 브라우저를 사용함
- 외국에 있는 이벤트 사이트에 들어감
    - 해당 사이트는 기본적으로 영어인데 한국어도 지원함
    - 클라이언트가 어떤 언어인지 정보가 없음
- 클라이언트가 서버로 전송할때 Accept-Language: ko 로 전송
- 서버는 ko 를 원한다는걸 알고 응답 데이터를 한국어로 보냄
- 이것은 매우 작은 기능이긴 하지만 헤더를 통해 해당 문제를 해결할 수 있다는 의미가 있음

## Accept-Langauge 복잡한 예시

- 만약 외국 사이트가 기본적으로 독일어인데 영어까지만 지원하는 상황이라면?
- 한국어로 요청하면 당연히 독일어가 먼저 오게됨
- **우리는 이럴때 우선순위가 필요**

## 협상과 우선순위 1

### Quality Values(q)

- **Quality Values(q) 값 사용**
- 0 ~ 1 **클수록 높은 우선순위**
- 생략하면 1
- Accept-Language: ko-KR, ko;q=0.9, en-US;q=0.8 en;q=0.7
    1. ko-KR q=1 
        - 생략 되어있어서 1
    2. ko;q=0.9
    3. en-US; q=0.8
    4. en;q=0.7
- 아까의 상황에서 다시 보게 되면 학국어를 원하다가 영어를 원하는걸 확인
- 그러면 영어를 보내주게됨
- 한국 브라우저에서 구글로 검색할때 accept 를 확인해보면 저렇게 되어있음

## 협상과 우선순위 2

### Quality Values(q)

- **구체적인 것을 우선한다**
- Accept: text/*, text/plain, text/plain;format=flowed, */*
    1. text/plain;format=flowed
    2. text/plain
    3. text/*
    4. */*
- 구체적인것일 수록 우선순위가 높음

## 협상과 우선순위 3

### Quality Values(q)

- 구체적인것을 기준으로 미디어 타입을 맞춘다
- Accept: **text/***;q=0.3, **text/html**;q=0.7, **text/html;level=1**, **text/html; level=2**; q=0.4, */*;q=0.5

| Media Type | Quality |
| --- | --- |
| text/html;level=1 | 1 |
| text/html | 0.7 |
| text/plain | 0.3 |
| image/jpeg | 0.5 |
| text/html;level=2 | 0.4 |
| text/html;llevel=3 | 0.7 |
- text plain 을 보면  text/* 이게 plain 이랑 맞아 떨어져서 0.3이

# 전송 방식

## 단순 전송

### Content-Length

- 길이값을 알 때 사용
- 한번에 요청해서 한번에 데이터를 다 받는 방식이라 단순 전송 임

## 압축 전송

- 서버에서 gzip 같은걸로 데이터를 줄어들게 만듬
- Content-Encoding 을 추가적으로 넣어줘야 클아이언트가 해제 가능함

## 분할 전송

- Transfer-Encoding 을 추가
    - Transfer-Encoding: chunked
        - chunk: 덩어리
        - 덩어리로 쪼개서 보낸다는 의미

5
Hello
5World
0
\r\n

- 이런식으로 5바이트 먼저 보내고 데이터를 보냄
- 네트워크가 이렇게 실제로 돌아감
- 마지막에는 0이라고 보내고 개행문자를 추가해줘야됨
- 용량이 너무 커서 보내는대로 표시를 해줘야 될 때 사용
- **Content-Length 를 넣으면 안됨!**
    - 길이가 예상이 안되기 때

## 범위 전송

### Range, Content-Range

- 이미지 같은걸 받는데 만약 절반정도 받다가 끊기면?
    - 이럴 경우에 범위를 지정해서 데이터를 전송해 달라고 요청하는 방식
- Content-Range: bytes 1001-2000 / 2000
    - 이런

# 일반 정보

- From: 유저 에이전트의 이메일 정보
- Referer: 이전 웹 페이지 주소
- User-Agent: 유저 에이전트 어플리케이션 정보
- Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
- Date: 메시지가 생성된 날

- 정보성 헤더

## From

### 유저 에이전트의 이메일 정보

- 일반적으로 잘 사용되지 않음
- 검색 엔진 같은곳에서, 주로 사용
- 요청에서 사용
    - 만약에 크롤링 같은거를 통해서 우리 사이트의 정보를 가져가려고 할대 가져가지 않도록 정보를 주는 용도?

## Referer

### 이전 웹 페이지 주소

- 현재 요청된 페이지의 이전 웹 페이지 주소
    - 개발자 도구의 Request Headers 를 보면 referer 가 있음
        - 구글 → 위키피디아
        - referer: www.google.com 이 나옴
- A → B 로 이동하는 경우 B를 요청할 때 Refer:A 를 포함해서 요청
- Referer를 사용해서 유입 경로 분석 가능
- 요청에서 사용
    - Request

- 참고: referer 는 referrer 의 오타
    - 과거에 오타가 난 상태에서 HTTP 가 배포가 나가버려서 돌아가기에 너무 많이 가버림

## User-Agent

### 유저 에이전트 어플리케이션 정보

- user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/
537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36
- 클라이언트의 어플리케이션 정보(웹 브라우저 정보 등등)
    - 내 웹 브라우저 정보 또는 클라이언트 어플리케이션 정보
- 통계 정보
- 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
    - 서버 입장에서 매우 좋음
    - 특정 브라우저에서 에러가 생기는걸 확인 할 수 있음
- 요청에서 사용

## Server

### 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보

- Server: Apache/2.2.22 (Debian)
- server: nginx
- 응답에서 사용

- ORIGIN 서버
    - HTTP 요청을 보내면 중간에 여러 프록시 서버를 거침
    - 중간 단계의 캐시 서버 이런것 말고 그 끝에서 내 요청을 받는 마지막 서버
    - 실제 어플리케이션에서 나의 표현 데이터를 만들어주는 바로 그 서버를 오리진 서버라고 함

## Date

### 메시지가 발생한 날짜와 시간

- Date: Tue 15 Nov 1994 08:12:31 GMT
- 응답에서 사용
- 과거에서는 요청에서도 사용했는데 최신 스펙에서는 응답에서만 사용

# 특별한 정보

- Host: 요청한 호스트 정보 (도메인)
- Location: 페이지 리다이렉션
- Allow 허용 가능한 HTTP 메소드
- Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

## Host

### 요청한 호스트 정보

- **매우 중요함!!**
- 요청에서 사용
    - 필수값
    - 다른 헤더들은 필수 헤더가 거의 없는데 이거는 필수값음
- 하나의 서버가 여러 도메인을 처리해야 할 때
    - 하나의 IP 주소에 여러 도메인이 적용되어 있을때

### 예제

- 가상 호스트를 통해 여러 도메인을 한번에 처리 할 수 있는 서버
    - 실제 어플리케이션이 여러개 구동 될 수 있음
    - 서버 아이피가 200.200.2002 여도 여러개의 도메인을 가질 수 잇음
- **호스트가 만약 없다면?**
    - DNS 를 통해 결국 아이피 통신을 하게 되는데 클라이언트는 어떤 아이피로 접근해야될 지 알 수 없음
    - Host 라는 헤더에 도메인을 넣어서 전송
    - **이것을 가상 호스팅이라고 함**
- 

## Location

### 페이지 리다이렉션

- 웹 브라우저는 3xx 응답에 결과에 Location 헤더가 있으면, Location 위치로 자동 이동
    - 그동안 강의에서 많이보여줬
- 응답코드 3xx에서 설명
- 201(Created): Location 값은 요청에 의해 생성된 리소스 URI
- 3xx(Redirection): Location 값은 요청을 자동으로 리다이렉션하기 위한 대상 리소스를 가르킴

## Allow

### 허용 가능한 HTTP 메소드

- 405 (Method Not Allowed) 에서 응답에 포함해야함
- Allow: GET HEAD PUT
- url 경로는 있지만 해당 메소드를 제공하는 API 가 없다면 405 오류를 내리면서 응답에 어떤 메소드를 지원하는지 보내줌
- 서버에서 많이 구현은 안되어있음

## Retry-After

### 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

- 503 (Service Unavailable): 서비스가 언제까지 불능인지 알려 줄 수 있음
- Retry-After: Fri 31 Dec 1999 23:59:59 GMT
    - 날짜 표기
- Retry-After: 120
    - 초단위 표현

# 인증

## Authorization: 클라이언트 인증 정보를 서버에 전달

- Authorization: Basic xxxxxxxxxxxxxx
- 인증관련 여러 메커니즘이 있는데 OAuth JWT 마다 달라서 인증 내용을 공부해야 어떤 헤더를 넣어야되는지 알수있음

## WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의

- 리소스 접근시 필요한 인정 방법 정의
- 401 Unauthorized 응답과 함께 사용
    - 401 오류가 날때 아래에 이런 정보를 넘겨줘야
- WWW-Authenticate: Newatuh realm=”apps” type=1, title=”Login to apps” , Basic realm=”simple”
- 

# 쿠키

## 쿠키 미사용

### 처음 웹 페이지 접근

- 만약 사용자가 페이지에 처음 들어와서 로그인을 안했음
- 정보를 보내서 로그인응 하고 응답을 받음
- 그리고 새로 고침 후 페이지를 다시 접근했을때 로그인을 하기 전 리소스를 전달해줌
- **서버에서는 로그인을 했는지 안했는지 알 수 없음**
- http 는 무상태(stateless) 프로토콜
- 클라이언트와 서버는 서로 상태를 유지하지 않음

### 대안

- 모든 요청에 사용자 정보를 포함해서 잔달함
- 이 대안은 심각한 문제가 있음
- **모든 요청에 사용자 정보가 포함되어야함**
    - 보안도 개발도 여러가지 문제가 발생할 수 밖에 없음

## 모든 요청에 정보를 넘기는 문제

- 모든 요청에 사용자 정보가 포함되도록 개발해야함
    - 개발자가 힘듬
- 브라우저를 완전히 종료하고 다시 열면?
    - 요즘은 웹 스토리지라는곳에 저장을 함

## 쿠키

### 로그인

- 서버는 Set-Cookie 쿠키 헤더를 만들어서 유저 정보를 보냄
- 클라이언트는 쿠키 저장소가 있는데 쿠키 저장소에 저장

### 로그인 이후 웹 페이지 접근

- 이제 자동으로 웹브라우저는 쿠키를 무조건 뒤져서 Cookie 라는 헤더를 만들어서 전달함
- 이제 서버는 해당 쿠키를 읽고 유저를 확인함
- 모든 정보에 자동으로 포함
    - 이렇게 되면 보안에 문제가 되서 제약하는 방법이 생김

### 제약 방법

- 예) set-cookie: **sessionld**=**abcde1234; expires**=Sat, 26-Dec-2020 00:00:00 GMT; **path**=/; **domain** =. [google.com](http://google.com/); **Secure**
    - 세션 아이디
    - 쿠키 만료 시간
    - 허용 할 경로
    - 허용 할 도메인
    - 쿠키에 보안 정보를 넣는다는걸 알 수 있음
- 사용처
    - 사용자 로그인 세션 관리
        - 보통은 로그인이 되면 세션 키라는걸 데이터베이스에 저장 하고 세션 아이디를 클라이언트한테 반환
        - 클라이언트는 세션 아이디를 서버에 전송하고 서버는 해당 세션 아이디를 보고서 인증 확인
    - 광고 정보 트래킹
        - 이 웹 브라우저를 사용하는 사람들이 주로 이런 광고를 보는구나 라는걸 알 수 잇음
- 쿠키 정보는 항상 서버에 전송됨
    - **네트워크 트래픽 추가 유발**
        - 최소한의 정보만 사용
            - 세션 id, 인증 토큰
    - 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지(LocalStorage, sessionStorage) 참고
        - 쿠키처럼 쓰고싶지만 요청할때마다 보내지는 않고 클라이언트가 보관하고 필요할때만 보내는 정보를 사용하고 싶을때 웹 스토리지를 사용
        - **쿠키는 일단 설정하면 무조건 서버에 다 보냄**
- 주의!
    - 보안에 민감한 데이터는 저장하면 안됨
        - 주민등록번호, 신용카드 번호 등등
        - 

## Set-Cookie

### 서버에서 클라이언트로 쿠키 전달(응답)

## Cookie

### 클라이언트가 서버에서 받은 쿠키를 저장하고 HTTP 요청시 서버로 전달

## 쿠키 - 생명주기

### Expires, max-age

- 쿠키를 무제한으로 보관 할 수 없
- Set-Cookie: expires=Sat, 26-Dec-2020 00:00:00 GMT
    - 만료일이 되면 쿠키 삭제
- Set-Cookie: max-age=3600(3600 초)
    - 0이나 음수를 지정하면 쿠키 삭제
- **세션 쿠키**: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
    - 브라우저를 껏다 키면 다시 로그인 하는 경우
- **영속 쿠키**: 만료 날짜를 입력하면 해당 날짜까지 유지

## 쿠키 - 도메인

- **내가 지정한 쿠키가 아무 도메인마다 다 가지고있으면 큰일남**
- ex) domain=example.org
- **명시: 명시한 문서 기준 도메인 + 서브 도메인 포함**
    - domain=example.org 를 지정해서 쿠키 생성
        - example.org 는 물론이고
        - dev.example.org도 쿠키 접근
- **생략: 현재 문서 기준 도메인만 적용**
    - example.org 에서 쿠키를 생성하고 domain 지정을 생략
        - example.org 에서만 쿠키 접근
        - dev.example.org도 쿠키 미접근

## 쿠키 - 경로

### path

- 예) path=/home
- 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
    - 도메인으로 필터를 하고 도메인 안의 경로 설정 가능
- 일반적으로 **path=/ 루트로 지정**
    - 한 도메인 안에서 보통 모든 쿠키를 전송하기를 원
- 예
    - path=/home 지정
    - /home → 가능
    - /home/level1 → 가능
    - /home/level1/level2 → 가
    - /hello → 불가능

## 쿠키 - 보안

### Secure HttpOnly SameSite

- Secure
    - 쿠키는 http https 를 구분하지 않고 전송
    - Secure 를 적용하면 https 인 경우에만 전송
- HttpOnly
    - xss 공격 방지
    - 자바스크립트에서 접근 불가
        - 원래는 가능했음
        - document.cookie
    - HTTP 전송에만 사용
- SameSite
    - XSRF 공격 방지
        - 보안과 관련된 내용이니까 알아보면 좋음
        - 내가 요청하는 도메인과 쿠키에 설정된 도메인이 같을 경우만 전송
            - 도메인이 달라도 전송할수는 있음
        - 이건 지원한지 얼마 안됬
    - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전